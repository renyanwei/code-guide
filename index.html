---
layout: default
---


<div class="heading" id="toc">
  <h2>目录</h2>
</div>
<div class="section toc">
  <div class="col">
    <h4><a href="#base">基础</a></h4>
    <ul>
      <li><a href="#base-md5">MD5计算</a></li>
      <li><a href="#base-urlencrypt">URL加密/校验</a></li>
      <li><a href="#base-pnpk">PN和PK安全机制</a></li>
      <li><a href="#base-json">JSON序列化/反序列化</a></li>
    </ul>
  </div>
  <div class="col">
    <h4><a href="#log">日志</a></h4>
    <ul>
      <li><a href="#log-memo">概述</a></li>
      <li><a href="#log-error">错误（Error）日志</a></li>
      <li><a href="#log-warn">警告（Warn）日志</a></li>
      <li><a href="#log-info">信息（Info）日志</a></li>
    </ul>
  </div>
</div>


<div class="section" id="golden-rule">
  <div class="col">
    <h2>黄金定律</h2>
    <p>永远遵循同一套编码规范 -- 可以是这里列出的，也可以是你自己总结的。如果你发现本规范中有任何错误，一块为本规范添加或贡献内容。</p>
  </div>
  <div class="col">
    <blockquote>
      <p>不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。</p>
    </blockquote>
  </div>
</div>



<div class="heading" id="base">
  <h2>基础</h2>
</div>

<div class="section" id="html-md5">
  <div class="col">
    <h3>MD5计算</h3>
      <p>目前C#内置的实现MD5计算方式有很多种，方式不同编码不同结果也不相同，因此我们统一规范采用MD5CryptoServiceProvider类进行计算，此方法已经被封装到Common中的MD5类Encrypt方法中。注意：判断MD5值是否相等应该忽略大小写。将要比较的两个MD5统一转成大写或小写形式再进行判断。</p>
  </div>
  <div class="col">
    {% highlight c# %}
using Common;
namespace Portal.Test
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(MD5.Encrypt("original string"));
        }
    }
}	
	{% endhighlight %}
  </div>
</div>

<div class="section" id="base-urlencrypt">
  <div class="col">
    <h3>URL加密/校验</h3>
    <p>在子系统、不同系统之间如果决定采用HTTP进行数据通讯时，应该对HTTP的请求方参数处理，生成唯一指纹，HTTP的接收方则应该对指纹进行校验，校验通过则表示为正常合法的请求，反之则应该进行驳回处理，目前相关方法已经封装到Common中的SafeUrlUtility类中。注意，加密、校验依赖于PN和PK机制，加密和校验过程中会读取WEB.Config设置的PN和PK，具体PN和PK机制详见相关的说明。</p>
  </div>
  <div class="col">
    {% highlight c# %}
/*
 *接口请求方
 */
static void Main(string[] args)
{
    //生成含有唯一指纹的安全URL,会在QueryString附加sign和pn参数
    string safeRequestUrl = SafeUrlUtility.HashUrlCreate("http://www.httpinterface.com/api/demoapi", new
    {
        param1 = "str1",
        param2 = "str2",
        //更多参数
    });
    //开始请求，获取结果
    dynamic result = ApiClient.GET(safeRequestUrl);
    //根据result进行对应处理
}

/*
 *接口接收方
 */
public ActionResult demoapi(string pn, string param1, string param2)
{
    //根据pn查询数据库获取到对应的pk
    //string pk=GetPKforPN(pn);
    //校验请求是否合法
    bool issafe = SafeUrlUtility.HashUrlVerify(pk, Request);
    if (issafe)
    {
        //请求合法，执行其他业务逻辑
    }
    else
    {
        //请求不合法，驳回
    }
}
	{% endhighlight %}
  </div>
</div>

<div class="section" id="base-pnpk">
  <div class="col">
    <h3>PN和PK安全机制</h3>
    <p>在进行对对系统架构进行合理的拆解和封装形成各自独立的服务时势必会面临系统之间通过HTTP进行数据的互相访问的场景，特设置PN和PK机制来解决这个问题：</p>
	<ul>
	<li>
	PN：每个子系统的唯一标识，通常会在HTTP请求中明文传送，参与加密计算并附加在请求的QueryString参数中。
	</li>
	<li>
	PK：每个PN对应的加密密钥，通常存储在Web.Config中，参数加密计算但不会在各个子系统之间通过HTTP传递。
	</li>
	</ul>
	<p>
	每个系统拥有唯一的PN和PK，应该存储在系统根目录Web.Config的appSettings节点。所有系统的PN和PK存储在Tiantis数据库中App_SimplyInfo表。
	</p>
  </div>
  <div class="col">
    {% highlight xml %}
<appSettings>
  <!--其他配置信息-->
  <add key="pn" value="00000213"/>
  <add key="pk" value="3c51704a09844314a74ec5fbec7c7a34"/>
</appSettings>
	{% endhighlight %}
  </div>
</div>

<div class="section" id="base-json">
  <div class="col">
    <h3>JSON序列化/反序列化</h3>
    <p>处理JSON在每个系统中用的频率非常高，不光是WEB项目，还有各种类库，都会有这方面的事情要处理，所以在Common项目中统一引用了JSON.NET，而其他项目如果需要用JSON.NET，引用Common就好了。这样整个解决方案只会有一次引用，可以避免上述问题的发生，具体JSON操作封装在JsonHelper类中的SerializeObject方法和DeserializeObject方法。</p>
    
  </div>
  <div class="col">
    {% highlight c# %}
static void Main(string[] args)
{
    //JSON序列化
    string json = Common.JsonHelper.SerializeObject(new { });

    //JSON反序列化
    dynamic obj=Common.JsonHelper.DeserializeObject(json);
    //JSON反序列化，泛型支持
    Model model = Common.JsonHelper.DeserializeObject<Model>(json);
}	
	{% endhighlight %}
  </div>
</div>

<div class="heading" id="log">
  <h2>日志</h2>
</div>

<div class="section" id="log-memo">
  <div class="col">
    <h3>概述</h3>
    <p>为了减少记录日志的复杂度以及统一规范日志的保存和查询，日志组件已经封装到Nuget包里。VS里下载即可</p>
	<p class="nuget-badge"><code>Install-Package Log.SDK</code></p>
  </div>
  <div class="col">
    {% highlight c# %}
class Program
{
    //使用静态变量声明，每个类只引用一次。
    static Log.SDK.LogHelper logger = Log.SDK.LogHelper.GetInstance(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
}
	{% endhighlight %}
  </div>
</div>

<div class="section" id="log-error">
  <div class="col">
    <h3>错误（Error）日志</h3>
    <p>错误（Error）日志仅仅在代码发生了不可预知（或忘记处理）的时候使用，一般情况下，不应该在除了Global.asax文件以外的地方使用，Error级别的日志的目的在于“检漏”，哪些异常发生了但是代码里没有被Try Catch处理，最后被Global.asax里HttpApplication类的Application_Error截获了，就用Error记录下。</p>
  </div>
  <div class="col">
    {% highlight c# %}
public class MvcApplication : System.Web.HttpApplication
{
    static Log.SDK.LogHelper logger = Log.SDK.LogHelper.GetInstance(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

    protected void Application_Error(object sender, EventArgs e)
    {
        var ex = Server.GetLastError();
        //记录错误(Error)级别的日志
        logger.Error(ex);
    }
}
	{% endhighlight %}
  </div>
</div>

<div class="section" id="log-warn">
  <div class="col">
    <h3>警告（Warn）日志</h3>
    <p>警告（Warn）级别的信息主要用于记录在业务实现的代码中一些可以预知并且做了一定防范，比如调用其他子系统或第三方的HTTP接口、查询数据库、或者其他复杂操作，在写代码的时候就已经知道这块将来可能会有问题并且对关键代码做了Try Catch处理。那么在Catch代码块就一定要记录日志。</p>
  </div>
  <div class="col">
    {% highlight c# %}
static void Main(string[] args)
{
    try
    {
        /*
         * HTTP调用
         * 数据库访问
         * 复杂运算、事务
         * 其他容易出错的代码
         */
    }
    catch (Exception ex)
    {
        /*
         * 其他的恢复性、提示性处理措施
         */
        //使用Warn级别的日志记录
        logger.Warn(ex);
    }
}	
	{% endhighlight %}
  </div>
</div>

<div class="section" id="log-info">
  <div class="col">
    <h3>信息（Info）日志</h3>
    <p>信息（Info）级别的日志可以记录一些常规的动作：如客户的登陆访问日志、敏感操作如修改密码、删除重要数据等，用这个级别来记录日志最合适，这样有一天追踪数据的流转过程和查询一些时间轴方面的信息会显得特别有用处。</p>
  </div>
  <div class="col">
    {% highlight c# %}
static void Login(string username, string password)
{
    //登陆成功
    logger.Info("用户:" + username + "在" + DateTime.Now + "登陆成功");
}
static void Delete(string id)
{
    //删除成功
    logger.Info("数据ID:" + id + "在" + DateTime.Now + "被删除");
}	
	{% endhighlight %}
  </div>
</div>
